<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flower Shader</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  .container { position: relative; }
  canvas { display: block; width: 100vw; height: 100vh; }
  .clean-btn { position: absolute; top: 20px; left: 20px; padding: 10px 15px; background: #fff; cursor: pointer; }
  .name { position: absolute; top: 20px; right: 20px; color: #fff; font-family: sans-serif; }
</style>
</head>
<body>
<div class="container">
    <canvas id="canvas"></canvas>
    <div class="clean-btn">clean the screen</div>
</div>
<div class="name">Click To Add Flowers</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
<script id="vertexShader" type="x-shader/x-vertex">
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = vec4(position, 1.0);
}
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
#define PI 3.14159265359
uniform float u_ratio;
uniform vec2 u_cursor;
uniform float u_stop_time;
uniform float u_clean;
uniform vec2 u_stop_randomizer;
uniform sampler2D u_texture;
varying vec2 vUv;

// Put your snoise, get_flower_shape, get_stem_shape functions here
// (copy exactly what you had in your code)

void main() {
    vec3 base = texture2D(u_texture, vUv).xyz;
    vec2 uv = vUv;
    uv.x *= u_ratio;
    vec2 cursor = vUv - u_cursor.xy;
    cursor.x *= u_ratio;

    vec3 stem_color = vec3(.1 + u_stop_randomizer[0] * .6, .6, .2);
    vec3 flower_color = vec3(.6 + .5 * u_stop_randomizer[1], .1, .9 - .5 * u_stop_randomizer[1]);

    float angle = .5 * (u_stop_randomizer[0] - .5);

    float stem_shape = get_stem_shape(cursor, uv, .003, angle);
    stem_shape += get_stem_shape(cursor + vec2(0., .2 + .5 * u_stop_randomizer[0]), uv, .003, angle);
    float stem_mask = 1. - get_stem_shape(cursor, uv, .004, angle);
    stem_mask -= get_stem_shape(cursor + vec2(0., .2 + .5 * u_stop_randomizer[0]), uv, .004, angle);

    float petals_back_number = 1. + floor(u_stop_randomizer[0] * 2.);
    float angle_offset = -(2. * step(0., angle) - 1.) * .1 * u_stop_time;
    float flower_back_shape = get_flower_shape(cursor, petals_back_number, angle + angle_offset, 1.5);
    float flower_back_mask = 1. - get_flower_shape(cursor, petals_back_number, angle + angle_offset, 1.6);

    float petals_front_number = 2. + floor(u_stop_randomizer[1] * 2.);
    float flower_front_shape = get_flower_shape(cursor, petals_front_number, angle, 1.);
    float flower_front_mask = 1. - get_flower_shape(cursor, petals_front_number, angle, .95);

    vec3 color = base;
    color *= stem_mask;
    color *= flower_back_mask;
    color *= flower_front_mask;

    color += (stem_shape * stem_color);
    color += (flower_back_shape * (flower_color + vec3(0., .8 * u_stop_time, 0.)));
    color += (flower_front_shape * flower_color);

    color.r *= 1. - (.5 * flower_back_shape * flower_front_shape);
    color.b *= 1. - (flower_back_shape * flower_front_shape);
    color *= u_clean;

    gl_FragColor = vec4(color, 1.0);
}
</script>

<script>
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({ canvas });
renderer.setSize(window.innerWidth, window.innerHeight);

const scene = new THREE.Scene();
const camera = new THREE.Camera();
camera.position.z = 1;

const geometry = new THREE.PlaneGeometry(2, 2);

const uniforms = {
    u_ratio: { value: window.innerWidth / window.innerHeight },
    u_cursor: { value: new THREE.Vector2(0.5, 0.5) },
    u_stop_time: { value: 0 },
    u_clean: { value: 1 },
    u_stop_randomizer: { value: new THREE.Vector2(Math.random(), Math.random()) },
    u_texture: { value: new THREE.Texture() }
};

const material = new THREE.ShaderMaterial({
    vertexShader: document.getElementById('vertexShader').textContent,
    fragmentShader: document.getElementById('fragmentShader').textContent,
    uniforms
});

const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);

function animate(time) {
    uniforms.u_stop_time.value = (time * 0.001) % 2;
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}
animate(0);

canvas.addEventListener('mousemove', (e) => {
    uniforms.u_cursor.value.x = e.clientX / window.innerWidth;
    uniforms.u_cursor.value.y = 1 - e.clientY / window.innerHeight;
});
</script>
</body>
</html>
